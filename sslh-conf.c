/* Generated by conf2struct (https://www.rutschle.net/tech/conf2struct)
 * on Tue Dec  4 21:49:45 2018. */



#define _GNU_SOURCE
#include <string.h>
#include <libconfig.h>
#include <stdlib.h>
#include "sslh-conf.h"

static int sslhcfg_protocols_parser(
        config_setting_t* cfg, 
        struct sslhcfg_protocols_item* sslhcfg_protocols, 
        const char** errmsg) 
{
        config_setting_t* setting;
        char* tmp;
        *errmsg = NULL;

        if (config_setting_lookup(cfg, "name")) {
            if (config_setting_lookup_string(cfg, "name", &sslhcfg_protocols->name) == CONFIG_FALSE) {
                *errmsg = "Parsing of option \"name\" failed";
                return 0;
            }
        } else {
            *errmsg = "Mandatory option \"sslhcfg_protocols.name\" is missing";
            return 0;
        }
        if (config_setting_lookup(cfg, "host")) {
            if (config_setting_lookup_string(cfg, "host", &sslhcfg_protocols->host) == CONFIG_FALSE) {
                *errmsg = "Parsing of option \"host\" failed";
                return 0;
            }
        } else {
            *errmsg = "Mandatory option \"sslhcfg_protocols.host\" is missing";
            return 0;
        }
        if (asprintf(&tmp, "%s", sslhcfg_protocols->host) == -1) {
            *errmsg = "asprintf: cannot allocate memory";
            return 0;
        }
        sslhcfg_protocols->host = tmp;
        if (config_setting_lookup(cfg, "port")) {
            if (config_setting_lookup_string(cfg, "port", &sslhcfg_protocols->port) == CONFIG_FALSE) {
                *errmsg = "Parsing of option \"port\" failed";
                return 0;
            }
        } else {
            *errmsg = "Mandatory option \"sslhcfg_protocols.port\" is missing";
            return 0;
        }
        if (asprintf(&tmp, "%s", sslhcfg_protocols->port) == -1) {
            *errmsg = "asprintf: cannot allocate memory";
            return 0;
        }
        sslhcfg_protocols->port = tmp;
        sslhcfg_protocols->service = NULL;
        if (config_setting_lookup(cfg, "service")) {
            if (config_setting_lookup_string(cfg, "service", &sslhcfg_protocols->service) == CONFIG_FALSE) {
                *errmsg = "Parsing of option \"service\" failed";
                return 0;
            } else {
		sslhcfg_protocols->service_is_present = 1;
	}
;
        }
        sslhcfg_protocols->fork = 0;
        if (config_setting_lookup(cfg, "fork")) {
            if (config_setting_lookup_bool(cfg, "fork", &sslhcfg_protocols->fork) == CONFIG_FALSE) {
                *errmsg = "Parsing of option \"fork\" failed";
                return 0;
            } ;
        }
        sslhcfg_protocols->log_level = 1;
        if (config_setting_lookup(cfg, "log_level")) {
            if (config_setting_lookup_int(cfg, "log_level", &sslhcfg_protocols->log_level) == CONFIG_FALSE) {
                *errmsg = "Parsing of option \"log_level\" failed";
                return 0;
            } ;
        }
        sslhcfg_protocols->keepalive = 0;
        if (config_setting_lookup(cfg, "keepalive")) {
            if (config_setting_lookup_bool(cfg, "keepalive", &sslhcfg_protocols->keepalive) == CONFIG_FALSE) {
                *errmsg = "Parsing of option \"keepalive\" failed";
                return 0;
            } ;
        }
        sslhcfg_protocols->sni_hostnames = NULL;
        sslhcfg_protocols->sni_hostnames_len = 0;
        if ((setting = config_setting_lookup(cfg, "sni_hostnames"))) {
            int len = config_setting_length(setting);
            sslhcfg_protocols->sni_hostnames = malloc(len * sizeof(*sslhcfg_protocols->sni_hostnames));
            sslhcfg_protocols->sni_hostnames_len = len;
            for (int i = 0; i < len; i++) {
                config_setting_t* s = config_setting_get_elem(setting, i);
                sslhcfg_protocols->sni_hostnames[i] = config_setting_get_string(s);
            }
        }
        sslhcfg_protocols->alpn_protocols = NULL;
        sslhcfg_protocols->alpn_protocols_len = 0;
        if ((setting = config_setting_lookup(cfg, "alpn_protocols"))) {
            int len = config_setting_length(setting);
            sslhcfg_protocols->alpn_protocols = malloc(len * sizeof(*sslhcfg_protocols->alpn_protocols));
            sslhcfg_protocols->alpn_protocols_len = len;
            for (int i = 0; i < len; i++) {
                config_setting_t* s = config_setting_get_elem(setting, i);
                sslhcfg_protocols->alpn_protocols[i] = config_setting_get_string(s);
            }
        }
        sslhcfg_protocols->regex_patterns = NULL;
        sslhcfg_protocols->regex_patterns_len = 0;
        if ((setting = config_setting_lookup(cfg, "regex_patterns"))) {
            int len = config_setting_length(setting);
            sslhcfg_protocols->regex_patterns = malloc(len * sizeof(*sslhcfg_protocols->regex_patterns));
            sslhcfg_protocols->regex_patterns_len = len;
            for (int i = 0; i < len; i++) {
                config_setting_t* s = config_setting_get_elem(setting, i);
                sslhcfg_protocols->regex_patterns[i] = config_setting_get_string(s);
            }
        }
	return 1;
}

static int sslhcfg_listen_parser(
        config_setting_t* cfg, 
        struct sslhcfg_listen_item* sslhcfg_listen, 
        const char** errmsg) 
{
        config_setting_t* setting;
        char* tmp;
        *errmsg = NULL;

        if (config_setting_lookup(cfg, "host")) {
            if (config_setting_lookup_string(cfg, "host", &sslhcfg_listen->host) == CONFIG_FALSE) {
                *errmsg = "Parsing of option \"host\" failed";
                return 0;
            }
        } else {
            *errmsg = "Mandatory option \"sslhcfg_listen.host\" is missing";
            return 0;
        }
        if (asprintf(&tmp, "%s", sslhcfg_listen->host) == -1) {
            *errmsg = "asprintf: cannot allocate memory";
            return 0;
        }
        sslhcfg_listen->host = tmp;
        if (config_setting_lookup(cfg, "port")) {
            if (config_setting_lookup_string(cfg, "port", &sslhcfg_listen->port) == CONFIG_FALSE) {
                *errmsg = "Parsing of option \"port\" failed";
                return 0;
            }
        } else {
            *errmsg = "Mandatory option \"sslhcfg_listen.port\" is missing";
            return 0;
        }
        if (asprintf(&tmp, "%s", sslhcfg_listen->port) == -1) {
            *errmsg = "asprintf: cannot allocate memory";
            return 0;
        }
        sslhcfg_listen->port = tmp;
        sslhcfg_listen->keepalive = 0;
        if (config_setting_lookup(cfg, "keepalive")) {
            if (config_setting_lookup_bool(cfg, "keepalive", &sslhcfg_listen->keepalive) == CONFIG_FALSE) {
                *errmsg = "Parsing of option \"keepalive\" failed";
                return 0;
            } ;
        }
	return 1;
}

static int sslhcfg_parser(
        config_setting_t* cfg, 
        struct sslhcfg_item* sslhcfg, 
        const char** errmsg) 
{
        config_setting_t* setting;
        char* tmp;
        *errmsg = NULL;

        sslhcfg->verbose = 0;
        if (config_setting_lookup(cfg, "verbose")) {
            if (config_setting_lookup_int(cfg, "verbose", &sslhcfg->verbose) == CONFIG_FALSE) {
                *errmsg = "Parsing of option \"verbose\" failed";
                return 0;
            } ;
        }
        sslhcfg->foreground = 0;
        if (config_setting_lookup(cfg, "foreground")) {
            if (config_setting_lookup_bool(cfg, "foreground", &sslhcfg->foreground) == CONFIG_FALSE) {
                *errmsg = "Parsing of option \"foreground\" failed";
                return 0;
            } ;
        }
        sslhcfg->inetd = 0;
        if (config_setting_lookup(cfg, "inetd")) {
            if (config_setting_lookup_bool(cfg, "inetd", &sslhcfg->inetd) == CONFIG_FALSE) {
                *errmsg = "Parsing of option \"inetd\" failed";
                return 0;
            } ;
        }
        sslhcfg->numeric = 0;
        if (config_setting_lookup(cfg, "numeric")) {
            if (config_setting_lookup_bool(cfg, "numeric", &sslhcfg->numeric) == CONFIG_FALSE) {
                *errmsg = "Parsing of option \"numeric\" failed";
                return 0;
            } ;
        }
        sslhcfg->transparent = 0;
        if (config_setting_lookup(cfg, "transparent")) {
            if (config_setting_lookup_bool(cfg, "transparent", &sslhcfg->transparent) == CONFIG_FALSE) {
                *errmsg = "Parsing of option \"transparent\" failed";
                return 0;
            } ;
        }
        sslhcfg->timeout = 2;
        if (config_setting_lookup(cfg, "timeout")) {
            if (config_setting_lookup_int(cfg, "timeout", &sslhcfg->timeout) == CONFIG_FALSE) {
                *errmsg = "Parsing of option \"timeout\" failed";
                return 0;
            } ;
        }
        sslhcfg->user = NULL;
        if (config_setting_lookup(cfg, "user")) {
            if (config_setting_lookup_string(cfg, "user", &sslhcfg->user) == CONFIG_FALSE) {
                *errmsg = "Parsing of option \"user\" failed";
                return 0;
            } else {
		sslhcfg->user_is_present = 1;
	}
;
        }
        sslhcfg->pidfile = NULL;
        if (config_setting_lookup(cfg, "pidfile")) {
            if (config_setting_lookup_string(cfg, "pidfile", &sslhcfg->pidfile) == CONFIG_FALSE) {
                *errmsg = "Parsing of option \"pidfile\" failed";
                return 0;
            } else {
		sslhcfg->pidfile_is_present = 1;
	}
;
        }
        sslhcfg->chroot = NULL;
        if (config_setting_lookup(cfg, "chroot")) {
            if (config_setting_lookup_string(cfg, "chroot", &sslhcfg->chroot) == CONFIG_FALSE) {
                *errmsg = "Parsing of option \"chroot\" failed";
                return 0;
            } else {
		sslhcfg->chroot_is_present = 1;
	}
;
        }
        sslhcfg->syslog_facility = "auth";
        if (config_setting_lookup(cfg, "syslog_facility")) {
            if (config_setting_lookup_string(cfg, "syslog_facility", &sslhcfg->syslog_facility) == CONFIG_FALSE) {
                *errmsg = "Parsing of option \"syslog_facility\" failed";
                return 0;
            } ;
        }
        sslhcfg->on_timeout = "ssh";
        if (config_setting_lookup(cfg, "on_timeout")) {
            if (config_setting_lookup_string(cfg, "on_timeout", &sslhcfg->on_timeout) == CONFIG_FALSE) {
                *errmsg = "Parsing of option \"on_timeout\" failed";
                return 0;
            } ;
        }

        sslhcfg->listen = NULL;
        sslhcfg->listen_len = 0;
        if ((setting = config_setting_lookup(cfg, "listen"))) {
            int len = config_setting_length(setting);
            sslhcfg->listen = malloc(len * sizeof(*sslhcfg->listen));
            sslhcfg->listen_len = len;
            for (int i = 0; i < len; i++) {
                config_setting_t* s = config_setting_get_elem(setting, i);
                int res = sslhcfg_listen_parser(s, &sslhcfg->listen[i], errmsg);
                if (!res) return 0;
            }
        }

        sslhcfg->protocols = NULL;
        sslhcfg->protocols_len = 0;
        if ((setting = config_setting_lookup(cfg, "protocols"))) {
            int len = config_setting_length(setting);
            sslhcfg->protocols = malloc(len * sizeof(*sslhcfg->protocols));
            sslhcfg->protocols_len = len;
            for (int i = 0; i < len; i++) {
                config_setting_t* s = config_setting_get_elem(setting, i);
                int res = sslhcfg_protocols_parser(s, &sslhcfg->protocols[i], errmsg);
                if (!res) return 0;
            }
        }
	return 1;
}

/* Public parser API: returns 0 on failure, 1 on success */
int sslhcfg_parse_file(const char* filename, struct sslhcfg_item* cfg, const char**errmsg)
{
    config_t c;

    config_init(&c);
    if (config_read_file(&c, filename) == CONFIG_FALSE) {
        if (config_error_line(&c) != 0) {
           asprintf(errmsg, "%s:%d:%s", 
                    filename,
                    config_error_line(&c),
                    config_error_text(&c));
           return 0;
        }
        asprintf(errmsg, "%s:%s", filename, config_error_text(&c));
        return 0;
    }
    return sslhcfg_parser(config_lookup(&c, "/"), cfg, errmsg);
}

static void indent(int depth) 
{
    int i;
    for (i = 0; i < depth; i++)
        printf("    ");
}

static void sslhcfg_protocols_print(
        struct sslhcfg_protocols_item* sslhcfg_protocols,
        int depth) 
{
        int i;
        indent(depth);
        printf("name: %s\n", sslhcfg_protocols->name);
        indent(depth);
        printf("host: %s\n", sslhcfg_protocols->host);
        indent(depth);
        printf("port: %s\n", sslhcfg_protocols->port);
        indent(depth);
        printf("service: %s\n", sslhcfg_protocols->service);
        indent(depth);
        printf("fork: %d\n", sslhcfg_protocols->fork);
        indent(depth);
        printf("log_level: %d\n", sslhcfg_protocols->log_level);
        indent(depth);
        printf("keepalive: %d\n", sslhcfg_protocols->keepalive);
        indent(depth);
        printf("sni_hostnames [%d]:\n", sslhcfg_protocols->sni_hostnames_len);
        for (i = 0; i < sslhcfg_protocols->sni_hostnames_len; i++) {
            indent(depth+1);
            printf("%d:\t%s\n", i, sslhcfg_protocols->sni_hostnames[i]);
        }
        indent(depth);
        printf("alpn_protocols [%d]:\n", sslhcfg_protocols->alpn_protocols_len);
        for (i = 0; i < sslhcfg_protocols->alpn_protocols_len; i++) {
            indent(depth+1);
            printf("%d:\t%s\n", i, sslhcfg_protocols->alpn_protocols[i]);
        }
        indent(depth);
        printf("regex_patterns [%d]:\n", sslhcfg_protocols->regex_patterns_len);
        for (i = 0; i < sslhcfg_protocols->regex_patterns_len; i++) {
            indent(depth+1);
            printf("%d:\t%s\n", i, sslhcfg_protocols->regex_patterns[i]);
        }
}

static void sslhcfg_listen_print(
        struct sslhcfg_listen_item* sslhcfg_listen,
        int depth) 
{
        int i;
        indent(depth);
        printf("host: %s\n", sslhcfg_listen->host);
        indent(depth);
        printf("port: %s\n", sslhcfg_listen->port);
        indent(depth);
        printf("keepalive: %d\n", sslhcfg_listen->keepalive);
}

void sslhcfg_print(
        struct sslhcfg_item* sslhcfg,
        int depth) 
{
        int i;
        indent(depth);
        printf("verbose: %d\n", sslhcfg->verbose);
        indent(depth);
        printf("foreground: %d\n", sslhcfg->foreground);
        indent(depth);
        printf("inetd: %d\n", sslhcfg->inetd);
        indent(depth);
        printf("numeric: %d\n", sslhcfg->numeric);
        indent(depth);
        printf("transparent: %d\n", sslhcfg->transparent);
        indent(depth);
        printf("timeout: %d\n", sslhcfg->timeout);
        indent(depth);
        printf("user: %s\n", sslhcfg->user);
        indent(depth);
        printf("pidfile: %s\n", sslhcfg->pidfile);
        indent(depth);
        printf("chroot: %s\n", sslhcfg->chroot);
        indent(depth);
        printf("syslog_facility: %s\n", sslhcfg->syslog_facility);
        indent(depth);
        printf("on_timeout: %s\n", sslhcfg->on_timeout);

        indent(depth);
        printf("listen [%d]:\n", sslhcfg->listen_len);
        for (int i = 0; i < sslhcfg->listen_len; i++) {
            sslhcfg_listen_print(&sslhcfg->listen[i], depth+1);
        }

        indent(depth);
        printf("protocols [%d]:\n", sslhcfg->protocols_len);
        for (int i = 0; i < sslhcfg->protocols_len; i++) {
            sslhcfg_protocols_print(&sslhcfg->protocols[i], depth+1);
        }
}
