/* Generated by conf2struct (https://www.rutschle.net/tech/conf2struct)
 * on Mon Dec  3 10:48:52 2018. */



#define _GNU_SOURCE
#include <string.h>
#include <libconfig.h>
#include <stdlib.h>
#include "sslh-conf.h"

static int config_protocols_parser(
        config_setting_t* cfg, 
        struct config_protocols_item* config_protocols, 
        const char** errmsg) 
{
        config_setting_t* setting;
        char* tmp;
        *errmsg = NULL;

        if (config_setting_lookup(cfg, "name")) {
            if (config_setting_lookup_string(cfg, "name", &config_protocols->name) == CONFIG_FALSE) {
                *errmsg = "Parsing of option \"name\" failed";
                return 0;
            }
        } else {
            *errmsg = "Mandatory option \"name\" is missing";
            return 0;
        }
        if (config_setting_lookup(cfg, "host")) {
            if (config_setting_lookup_string(cfg, "host", &config_protocols->host) == CONFIG_FALSE) {
                *errmsg = "Parsing of option \"host\" failed";
                return 0;
            }
        } else {
            *errmsg = "Mandatory option \"host\" is missing";
            return 0;
        }
        if (asprintf(&tmp, "%s", config_protocols->host) == -1) {
            *errmsg = "asprintf: cannot allocate memory";
            return 0;
        }
        config_protocols->host = tmp;
        if (config_setting_lookup(cfg, "port")) {
            if (config_setting_lookup_string(cfg, "port", &config_protocols->port) == CONFIG_FALSE) {
                *errmsg = "Parsing of option \"port\" failed";
                return 0;
            }
        } else {
            *errmsg = "Mandatory option \"port\" is missing";
            return 0;
        }
        if (asprintf(&tmp, "%s", config_protocols->port) == -1) {
            *errmsg = "asprintf: cannot allocate memory";
            return 0;
        }
        config_protocols->port = tmp;
        config_protocols->service = NULL;
        if (config_setting_lookup(cfg, "service")) {
            if (config_setting_lookup_string(cfg, "service", &config_protocols->service) == CONFIG_FALSE) {
                *errmsg = "Parsing of option \"service\" failed";
                return 0;
            } else {
		config_protocols->service_is_present = 1;
	}
;
        }
        config_protocols->fork = 0;
        if (config_setting_lookup(cfg, "fork")) {
            if (config_setting_lookup_bool(cfg, "fork", &config_protocols->fork) == CONFIG_FALSE) {
                *errmsg = "Parsing of option \"fork\" failed";
                return 0;
            } ;
        }
        config_protocols->log_level = 1;
        if (config_setting_lookup(cfg, "log_level")) {
            if (config_setting_lookup_int(cfg, "log_level", &config_protocols->log_level) == CONFIG_FALSE) {
                *errmsg = "Parsing of option \"log_level\" failed";
                return 0;
            } ;
        }
        config_protocols->keepalive = 0;
        if (config_setting_lookup(cfg, "keepalive")) {
            if (config_setting_lookup_bool(cfg, "keepalive", &config_protocols->keepalive) == CONFIG_FALSE) {
                *errmsg = "Parsing of option \"keepalive\" failed";
                return 0;
            } ;
        }
        config_protocols->sni_hostnames = NULL;
        config_protocols->sni_hostnames_len = 0;
        if ((setting = config_setting_lookup(cfg, "sni_hostnames"))) {
            int len = config_setting_length(setting);
            config_protocols->sni_hostnames = malloc(len * sizeof(*config_protocols->sni_hostnames));
            config_protocols->sni_hostnames_len = len;
            for (int i = 0; i < len; i++) {
                config_setting_t* s = config_setting_get_elem(setting, i);
                config_protocols->sni_hostnames[i] = config_setting_get_string(s);
            }
        }
        config_protocols->alpn_protocols = NULL;
        config_protocols->alpn_protocols_len = 0;
        if ((setting = config_setting_lookup(cfg, "alpn_protocols"))) {
            int len = config_setting_length(setting);
            config_protocols->alpn_protocols = malloc(len * sizeof(*config_protocols->alpn_protocols));
            config_protocols->alpn_protocols_len = len;
            for (int i = 0; i < len; i++) {
                config_setting_t* s = config_setting_get_elem(setting, i);
                config_protocols->alpn_protocols[i] = config_setting_get_string(s);
            }
        }
        config_protocols->regex_patterns = NULL;
        config_protocols->regex_patterns_len = 0;
        if ((setting = config_setting_lookup(cfg, "regex_patterns"))) {
            int len = config_setting_length(setting);
            config_protocols->regex_patterns = malloc(len * sizeof(*config_protocols->regex_patterns));
            config_protocols->regex_patterns_len = len;
            for (int i = 0; i < len; i++) {
                config_setting_t* s = config_setting_get_elem(setting, i);
                config_protocols->regex_patterns[i] = config_setting_get_string(s);
            }
        }
	return 1;
}

static int config_listen_parser(
        config_setting_t* cfg, 
        struct config_listen_item* config_listen, 
        const char** errmsg) 
{
        config_setting_t* setting;
        char* tmp;
        *errmsg = NULL;

        if (config_setting_lookup(cfg, "host")) {
            if (config_setting_lookup_string(cfg, "host", &config_listen->host) == CONFIG_FALSE) {
                *errmsg = "Parsing of option \"host\" failed";
                return 0;
            }
        } else {
            *errmsg = "Mandatory option \"host\" is missing";
            return 0;
        }
        if (asprintf(&tmp, "%s", config_listen->host) == -1) {
            *errmsg = "asprintf: cannot allocate memory";
            return 0;
        }
        config_listen->host = tmp;
        if (config_setting_lookup(cfg, "port")) {
            if (config_setting_lookup_string(cfg, "port", &config_listen->port) == CONFIG_FALSE) {
                *errmsg = "Parsing of option \"port\" failed";
                return 0;
            }
        } else {
            *errmsg = "Mandatory option \"port\" is missing";
            return 0;
        }
        if (asprintf(&tmp, "%s", config_listen->port) == -1) {
            *errmsg = "asprintf: cannot allocate memory";
            return 0;
        }
        config_listen->port = tmp;
        config_listen->keepalive = 0;
        if (config_setting_lookup(cfg, "keepalive")) {
            if (config_setting_lookup_bool(cfg, "keepalive", &config_listen->keepalive) == CONFIG_FALSE) {
                *errmsg = "Parsing of option \"keepalive\" failed";
                return 0;
            } ;
        }
	return 1;
}

static int config_parser(
        config_setting_t* cfg, 
        struct config_item* config, 
        const char** errmsg) 
{
        config_setting_t* setting;
        char* tmp;
        *errmsg = NULL;

        config->verbose = 0;
        if (config_setting_lookup(cfg, "verbose")) {
            if (config_setting_lookup_int(cfg, "verbose", &config->verbose) == CONFIG_FALSE) {
                *errmsg = "Parsing of option \"verbose\" failed";
                return 0;
            } ;
        }
        config->foreground = 0;
        if (config_setting_lookup(cfg, "foreground")) {
            if (config_setting_lookup_bool(cfg, "foreground", &config->foreground) == CONFIG_FALSE) {
                *errmsg = "Parsing of option \"foreground\" failed";
                return 0;
            } ;
        }
        config->inetd = 0;
        if (config_setting_lookup(cfg, "inetd")) {
            if (config_setting_lookup_bool(cfg, "inetd", &config->inetd) == CONFIG_FALSE) {
                *errmsg = "Parsing of option \"inetd\" failed";
                return 0;
            } ;
        }
        config->numeric = 0;
        if (config_setting_lookup(cfg, "numeric")) {
            if (config_setting_lookup_bool(cfg, "numeric", &config->numeric) == CONFIG_FALSE) {
                *errmsg = "Parsing of option \"numeric\" failed";
                return 0;
            } ;
        }
        config->transparent = 0;
        if (config_setting_lookup(cfg, "transparent")) {
            if (config_setting_lookup_bool(cfg, "transparent", &config->transparent) == CONFIG_FALSE) {
                *errmsg = "Parsing of option \"transparent\" failed";
                return 0;
            } ;
        }
        config->timeout = 2;
        if (config_setting_lookup(cfg, "timeout")) {
            if (config_setting_lookup_int(cfg, "timeout", &config->timeout) == CONFIG_FALSE) {
                *errmsg = "Parsing of option \"timeout\" failed";
                return 0;
            } ;
        }
        config->user = NULL;
        if (config_setting_lookup(cfg, "user")) {
            if (config_setting_lookup_string(cfg, "user", &config->user) == CONFIG_FALSE) {
                *errmsg = "Parsing of option \"user\" failed";
                return 0;
            } else {
		config->user_is_present = 1;
	}
;
        }
        config->pidfile = NULL;
        if (config_setting_lookup(cfg, "pidfile")) {
            if (config_setting_lookup_string(cfg, "pidfile", &config->pidfile) == CONFIG_FALSE) {
                *errmsg = "Parsing of option \"pidfile\" failed";
                return 0;
            } else {
		config->pidfile_is_present = 1;
	}
;
        }
        config->chroot = NULL;
        if (config_setting_lookup(cfg, "chroot")) {
            if (config_setting_lookup_string(cfg, "chroot", &config->chroot) == CONFIG_FALSE) {
                *errmsg = "Parsing of option \"chroot\" failed";
                return 0;
            } else {
		config->chroot_is_present = 1;
	}
;
        }
        config->syslog_facility = "auth";
        if (config_setting_lookup(cfg, "syslog_facility")) {
            if (config_setting_lookup_string(cfg, "syslog_facility", &config->syslog_facility) == CONFIG_FALSE) {
                *errmsg = "Parsing of option \"syslog_facility\" failed";
                return 0;
            } ;
        }
        config->on_timeout = "ssh";
        if (config_setting_lookup(cfg, "on_timeout")) {
            if (config_setting_lookup_string(cfg, "on_timeout", &config->on_timeout) == CONFIG_FALSE) {
                *errmsg = "Parsing of option \"on_timeout\" failed";
                return 0;
            } ;
        }

        config->listen = NULL;
        config->listen_len = 0;
        if ((setting = config_setting_lookup(cfg, "listen"))) {
            int len = config_setting_length(setting);
            config->listen = malloc(len * sizeof(*config->listen));
            config->listen_len = len;
            for (int i = 0; i < len; i++) {
                config_setting_t* s = config_setting_get_elem(setting, i);
                int res = config_listen_parser(s, &config->listen[i], errmsg);
                if (!res) return 0;
            }
        }

        config->protocols = NULL;
        config->protocols_len = 0;
        if ((setting = config_setting_lookup(cfg, "protocols"))) {
            int len = config_setting_length(setting);
            config->protocols = malloc(len * sizeof(*config->protocols));
            config->protocols_len = len;
            for (int i = 0; i < len; i++) {
                config_setting_t* s = config_setting_get_elem(setting, i);
                int res = config_protocols_parser(s, &config->protocols[i], errmsg);
                if (!res) return 0;
            }
        }
	return 1;
}

/* Public parser API: returns 0 on failure, 1 on success */
int config_parse_file(const char* filename, struct config_item* cfg, const char**errmsg)
{
    config_t c;

    config_init(&c);
    if (config_read_file(&c, filename) == CONFIG_FALSE) {
        if (config_error_line(&c) != 0) {
           asprintf(errmsg, "%s:%d:%s", 
                    filename,
                    config_error_line(&c),
                    config_error_text(&c));
           return 0;
        }
        asprintf(errmsg, "%s:%s", filename, config_error_text(&c));
        return 0;
    }
    return config_parser(config_lookup(&c, "/"), cfg, errmsg);
}

static void indent(int depth) 
{
    int i;
    for (i = 0; i < depth; i++)
        printf("    ");
}

static void config_protocols_print(
        struct config_protocols_item* config_protocols,
        int depth) 
{
        int i;
        indent(depth);
        printf("name: %s\n", config_protocols->name);
        indent(depth);
        printf("host: %s\n", config_protocols->host);
        indent(depth);
        printf("port: %s\n", config_protocols->port);
        indent(depth);
        printf("service: %s\n", config_protocols->service);
        indent(depth);
        printf("fork: %d\n", config_protocols->fork);
        indent(depth);
        printf("log_level: %d\n", config_protocols->log_level);
        indent(depth);
        printf("keepalive: %d\n", config_protocols->keepalive);
        indent(depth);
        printf("sni_hostnames [%d]:\n", config_protocols->sni_hostnames_len);
        for (i = 0; i < config_protocols->sni_hostnames_len; i++) {
            indent(depth+1);
            printf("%d:\t%s\n", i, config_protocols->sni_hostnames[i]);
        }
        indent(depth);
        printf("alpn_protocols [%d]:\n", config_protocols->alpn_protocols_len);
        for (i = 0; i < config_protocols->alpn_protocols_len; i++) {
            indent(depth+1);
            printf("%d:\t%s\n", i, config_protocols->alpn_protocols[i]);
        }
        indent(depth);
        printf("regex_patterns [%d]:\n", config_protocols->regex_patterns_len);
        for (i = 0; i < config_protocols->regex_patterns_len; i++) {
            indent(depth+1);
            printf("%d:\t%s\n", i, config_protocols->regex_patterns[i]);
        }
   printf("\n");
}

static void config_listen_print(
        struct config_listen_item* config_listen,
        int depth) 
{
        int i;
        indent(depth);
        printf("host: %s\n", config_listen->host);
        indent(depth);
        printf("port: %s\n", config_listen->port);
        indent(depth);
        printf("keepalive: %d\n", config_listen->keepalive);
   printf("\n");
}

void config_print(
        struct config_item* config,
        int depth) 
{
        int i;
        indent(depth);
        printf("verbose: %d\n", config->verbose);
        indent(depth);
        printf("foreground: %d\n", config->foreground);
        indent(depth);
        printf("inetd: %d\n", config->inetd);
        indent(depth);
        printf("numeric: %d\n", config->numeric);
        indent(depth);
        printf("transparent: %d\n", config->transparent);
        indent(depth);
        printf("timeout: %d\n", config->timeout);
        indent(depth);
        printf("user: %s\n", config->user);
        indent(depth);
        printf("pidfile: %s\n", config->pidfile);
        indent(depth);
        printf("chroot: %s\n", config->chroot);
        indent(depth);
        printf("syslog_facility: %s\n", config->syslog_facility);
        indent(depth);
        printf("on_timeout: %s\n", config->on_timeout);

        indent(depth);
        printf("listen [%d]:\n", config->listen_len);
        for (int i = 0; i < config->listen_len; i++) {
            config_listen_print(&config->listen[i], depth+1);
        }

        indent(depth);
        printf("protocols [%d]:\n", config->protocols_len);
        for (int i = 0; i < config->protocols_len; i++) {
            config_protocols_print(&config->protocols[i], depth+1);
        }
   printf("\n");
}
